#!/usr/bin/env python3
"""
SDLC Iterator Agent with Timeout Recovery
Automatically cycles through develop‚Üítest‚Üídeploy‚Üídocument until production-ready
Handles Claude timeouts by scheduling retries every 30 minutes
"""

import subprocess
import json
import time
import os
import pickle
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import schedule
import threading
import queue

class SDLCIteratorAgent:
    def __init__(self):
        self.base_dir = Path("E:/Projects")
        self.state_file = self.base_dir / ".agent_state.pkl"
        self.retry_file = self.base_dir / ".agent_retry_queue.json"
        
        # SDLC phases in order
        self.sdlc_phases = ["develop", "test", "deploy", "document"]
        
        # Load saved state if exists
        self.state = self.load_state()
        self.retry_queue = self.load_retry_queue()
        
        # Track Claude availability
        self.claude_available = True
        self.last_timeout = None
        
    def load_state(self) -> Dict:
        """Load saved agent state"""
        if self.state_file.exists():
            try:
                with open(self.state_file, 'rb') as f:
                    return pickle.load(f)
            except:
                pass
        
        return {
            'current_services': {},  # service -> current phase
            'completed_services': [],
            'production_ready': [],
            'iteration_count': {}
        }
    
    def save_state(self):
        """Save current state"""
        with open(self.state_file, 'wb') as f:
            pickle.dump(self.state, f)
    
    def load_retry_queue(self) -> List:
        """Load tasks that need retry"""
        if self.retry_file.exists():
            try:
                with open(self.retry_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return []
    
    def save_retry_queue(self):
        """Save retry queue"""
        with open(self.retry_file, 'w') as f:
            json.dump(self.retry_queue, f, indent=2)
    
    def create_sdlc_issue(self, service: str, repo: str, phase: str, iteration: int) -> Optional[int]:
        """Create GitHub issue for SDLC phase"""
        
        title = f"[SDLC-{iteration}] {service}: {phase.capitalize()} Phase"
        
        body = f"""# SDLC Automatic Iteration

**Service**: {service}
**Repository**: {repo}
**Phase**: {phase}
**Iteration**: {iteration}
**Timestamp**: {datetime.now().isoformat()}

## Phase Objectives

"""
        
        if phase == "develop":
            body += """### Development Phase
- [ ] Code review and improvements
- [ ] Refactor problematic areas
- [ ] Add missing functionality
- [ ] Update dependencies
- [ ] Fix linting issues

**Agent Actions**:
- Analyze code quality
- Suggest improvements
- Check for security issues
- Validate best practices
"""
        
        elif phase == "test":
            body += """### Testing Phase
- [ ] Run unit tests
- [ ] Run integration tests
- [ ] Check code coverage (target: 80%)
- [ ] Performance benchmarks
- [ ] Security scanning

**Success Criteria**:
- All tests pass
- Coverage > 80%
- No critical vulnerabilities
- Performance within limits
"""
        
        elif phase == "deploy":
            body += """### Deployment Phase
- [ ] Build artifacts
- [ ] Validate CloudFormation/Serverless
- [ ] Check environment variables
- [ ] Verify IAM permissions
- [ ] Create deployment package

**Deployment Checklist**:
- Lambda function packaged
- Dependencies included
- Configuration validated
- Rollback plan ready
"""
        
        elif phase == "document":
            body += """### Documentation Phase
- [ ] Update README
- [ ] API documentation
- [ ] Deployment guide
- [ ] Troubleshooting guide
- [ ] Version changelog

**Documentation Standards**:
- Clear examples
- All endpoints documented
- Environment variables listed
- Common issues addressed
"""
        
        body += f"""

## Automation
This issue was automatically created by the SDLC Iterator Agent.
The agent will process this phase and move to the next one automatically.

## Previous Iterations
Iteration {iteration} of the SDLC cycle for {service}.
Previous phases completed: {iteration * 4 + self.sdlc_phases.index(phase)}

---
*Auto-generated by SDLC Iterator Agent*
"""
        
        # Create issue
        cmd = f'gh issue create --repo stevesurles/{repo} --title "{title}" --body "{body}" --label "agent-task,sdlc,{phase}"'
        
        try:
            # Save body to file to avoid escaping issues
            body_file = self.base_dir / "temp_issue_body.md"
            body_file.write_text(body)
            
            cmd = f'gh issue create --repo stevesurles/{repo} --title "{title}" --body-file "{body_file}" --label "agent-task,sdlc,{phase}"'
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Extract issue number from output
                import re
                match = re.search(r'/issues/(\d+)', result.stdout)
                if match:
                    issue_number = int(match.group(1))
                    print(f"‚úÖ Created issue #{issue_number} for {service} {phase} phase")
                    body_file.unlink(missing_ok=True)
                    return issue_number
            
            body_file.unlink(missing_ok=True)
            
        except Exception as e:
            print(f"Error creating issue: {e}")
        
        return None
    
    def execute_phase(self, service: str, repo: str, phase: str) -> Dict[str, Any]:
        """Execute SDLC phase for a service"""
        
        print(f"\nüîÑ Executing {phase} phase for {service}...")
        
        results = {
            'service': service,
            'phase': phase,
            'timestamp': datetime.now().isoformat(),
            'success': False,
            'metrics': {},
            'issues': [],
            'ready_for_next': False
        }
        
        service_path = self.base_dir / repo / service
        
        try:
            if phase == "develop":
                results = self.execute_develop_phase(service, service_path, results)
                
            elif phase == "test":
                results = self.execute_test_phase(service, service_path, results)
                
            elif phase == "deploy":
                results = self.execute_deploy_phase(service, service_path, results)
                
            elif phase == "document":
                results = self.execute_document_phase(service, service_path, results)
            
            # Check if phase passed
            results['ready_for_next'] = self.check_phase_success(phase, results)
            
        except Exception as e:
            results['issues'].append(f"Phase execution error: {str(e)}")
            
            # Check if it's a Claude timeout
            if "timeout" in str(e).lower() or "rate limit" in str(e).lower():
                self.handle_claude_timeout(service, repo, phase)
        
        return results
    
    def execute_develop_phase(self, service: str, path: Path, results: Dict) -> Dict:
        """Execute development phase"""
        
        # Run linting
        if (path / "package.json").exists():
            try:
                lint_result = subprocess.run(
                    "npm run lint",
                    shell=True,
                    capture_output=True,
                    text=True,
                    cwd=str(path),
                    timeout=30
                )
                
                if lint_result.returncode == 0:
                    results['metrics']['lint'] = 'passed'
                else:
                    results['metrics']['lint'] = 'failed'
                    results['issues'].append("Linting errors found")
                    
            except:
                results['metrics']['lint'] = 'not configured'
        
        # Check for TODOs and FIXMEs
        try:
            grep_result = subprocess.run(
                'grep -r "TODO\\|FIXME" --include="*.js" --include="*.ts" .',
                shell=True,
                capture_output=True,
                text=True,
                cwd=str(path)
            )
            
            todo_count = len(grep_result.stdout.strip().split('\n')) if grep_result.stdout else 0
            results['metrics']['todos'] = todo_count
            
            if todo_count > 5:
                results['issues'].append(f"High number of TODOs: {todo_count}")
                
        except:
            pass
        
        results['success'] = len(results['issues']) == 0
        return results
    
    def execute_test_phase(self, service: str, path: Path, results: Dict) -> Dict:
        """Execute testing phase"""
        
        # Run tests
        if (path / "package.json").exists():
            try:
                test_result = subprocess.run(
                    "npm test -- --coverage",
                    shell=True,
                    capture_output=True,
                    text=True,
                    cwd=str(path),
                    timeout=120
                )
                
                if test_result.returncode == 0:
                    results['metrics']['tests'] = 'passed'
                    
                    # Try to extract coverage
                    import re
                    coverage_match = re.search(r'All files[^|]*\|\s*([\d.]+)', test_result.stdout)
                    if coverage_match:
                        coverage = float(coverage_match.group(1))
                        results['metrics']['coverage'] = coverage
                        
                        if coverage < 80:
                            results['issues'].append(f"Coverage below 80%: {coverage}%")
                else:
                    results['metrics']['tests'] = 'failed'
                    results['issues'].append("Tests failed")
                    
            except subprocess.TimeoutExpired:
                results['issues'].append("Tests timed out")
            except:
                results['metrics']['tests'] = 'not configured'
        
        results['success'] = results['metrics'].get('tests') == 'passed'
        return results
    
    def execute_deploy_phase(self, service: str, path: Path, results: Dict) -> Dict:
        """Execute deployment phase"""
        
        # Check for deployment configuration
        deploy_files = [
            "serverless.yml",
            "cloudformation.yaml",
            "cloudformation.json",
            "template.yaml"
        ]
        
        has_deploy_config = any((path / f).exists() for f in deploy_files)
        results['metrics']['deploy_config'] = has_deploy_config
        
        if not has_deploy_config:
            results['issues'].append("No deployment configuration found")
        
        # Validate CloudFormation if exists
        cf_file = None
        for f in ["cloudformation.yaml", "template.yaml"]:
            if (path / f).exists():
                cf_file = path / f
                break
        
        if cf_file:
            try:
                validate_result = subprocess.run(
                    f"aws cloudformation validate-template --template-body file://{cf_file}",
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if validate_result.returncode == 0:
                    results['metrics']['cf_valid'] = True
                else:
                    results['metrics']['cf_valid'] = False
                    results['issues'].append("CloudFormation template invalid")
                    
            except:
                pass
        
        # Check for required environment variables
        env_file = path / ".env.example"
        if env_file.exists():
            results['metrics']['env_documented'] = True
        else:
            results['issues'].append("Missing .env.example file")
        
        results['success'] = len(results['issues']) == 0
        return results
    
    def execute_document_phase(self, service: str, path: Path, results: Dict) -> Dict:
        """Execute documentation phase"""
        
        # Check for documentation files
        docs_to_check = [
            ("README.md", "readme"),
            ("API.md", "api_docs"),
            ("DEPLOYMENT.md", "deploy_docs"),
            ("CHANGELOG.md", "changelog")
        ]
        
        for doc_file, metric_name in docs_to_check:
            if (path / doc_file).exists():
                results['metrics'][metric_name] = True
                
                # Check if recently updated
                mod_time = (path / doc_file).stat().st_mtime
                days_old = (time.time() - mod_time) / 86400
                
                if days_old > 30:
                    results['issues'].append(f"{doc_file} not updated in {int(days_old)} days")
            else:
                results['metrics'][metric_name] = False
                if doc_file == "README.md":  # README is required
                    results['issues'].append(f"Missing {doc_file}")
        
        results['success'] = results['metrics'].get('readme', False)
        return results
    
    def check_phase_success(self, phase: str, results: Dict) -> bool:
        """Check if phase completed successfully"""
        
        if phase == "develop":
            return results['metrics'].get('lint') == 'passed' or len(results['issues']) < 2
            
        elif phase == "test":
            return (results['metrics'].get('tests') == 'passed' and 
                   results['metrics'].get('coverage', 0) >= 80)
            
        elif phase == "deploy":
            return results['metrics'].get('deploy_config', False)
            
        elif phase == "document":
            return results['metrics'].get('readme', False)
        
        return False
    
    def handle_claude_timeout(self, service: str, repo: str, phase: str):
        """Handle Claude timeout by scheduling retry"""
        
        print(f"\n‚è∞ Claude timeout detected for {service}")
        
        self.claude_available = False
        self.last_timeout = datetime.now()
        
        # Add to retry queue
        retry_task = {
            'service': service,
            'repo': repo,
            'phase': phase,
            'scheduled_retry': (datetime.now() + timedelta(minutes=35)).isoformat(),
            'attempts': 1
        }
        
        # Check if already in queue
        existing = False
        for task in self.retry_queue:
            if task['service'] == service and task['phase'] == phase:
                task['attempts'] += 1
                existing = True
                break
        
        if not existing:
            self.retry_queue.append(retry_task)
        
        self.save_retry_queue()
        
        print(f"üìÖ Scheduled retry for {service} at {retry_task['scheduled_retry']}")
        print("Will check again in 35 minutes (30 min wait + 5 min buffer)")
    
    def check_retries(self):
        """Check if any retries are due"""
        
        if not self.retry_queue:
            return
        
        current_time = datetime.now()
        tasks_to_retry = []
        
        for task in self.retry_queue[:]:  # Copy to iterate safely
            retry_time = datetime.fromisoformat(task['scheduled_retry'])
            
            if current_time >= retry_time:
                print(f"\nüîÑ Retrying {task['service']} - {task['phase']} phase")
                tasks_to_retry.append(task)
                self.retry_queue.remove(task)
        
        if tasks_to_retry:
            self.save_retry_queue()
            
            for task in tasks_to_retry:
                # Check if Claude is available
                if self.test_claude_availability():
                    self.claude_available = True
                    results = self.execute_phase(task['service'], task['repo'], task['phase'])
                    
                    if not self.claude_available:
                        # Still timing out, reschedule
                        print(f"Still unavailable, rescheduling {task['service']}")
                        task['attempts'] += 1
                        task['scheduled_retry'] = (datetime.now() + timedelta(minutes=30)).isoformat()
                        self.retry_queue.append(task)
                        self.save_retry_queue()
                else:
                    # Not available yet, reschedule
                    task['scheduled_retry'] = (datetime.now() + timedelta(minutes=30)).isoformat()
                    self.retry_queue.append(task)
                    self.save_retry_queue()
    
    def test_claude_availability(self) -> bool:
        """Quick test to see if Claude is available"""
        
        try:
            # Simple gh copilot test
            cmd = 'echo "1" | timeout 5 gh copilot suggest "test"'
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except:
            return False
    
    def iterate_service_sdlc(self, service: str, repo: str):
        """Iterate through SDLC for a service until production-ready"""
        
        iteration = self.state['iteration_count'].get(service, 0) + 1
        self.state['iteration_count'][service] = iteration
        
        print(f"\nüöÄ Starting SDLC iteration {iteration} for {service}")
        
        current_phase_index = 0
        if service in self.state['current_services']:
            current_phase = self.state['current_services'][service]
            if current_phase in self.sdlc_phases:
                current_phase_index = self.sdlc_phases.index(current_phase)
        
        production_ready = False
        phases_passed = []
        
        for phase in self.sdlc_phases[current_phase_index:]:
            print(f"\nüìç Phase: {phase}")
            
            # Create issue for phase
            issue_number = self.create_sdlc_issue(service, repo, phase, iteration)
            
            # Execute phase
            results = self.execute_phase(service, repo, phase)
            
            # Update issue with results
            if issue_number:
                self.update_issue_with_phase_results(repo, issue_number, results)
            
            if results['ready_for_next']:
                phases_passed.append(phase)
                print(f"   ‚úÖ {phase} phase passed")
                
                # Update state
                next_phase_index = self.sdlc_phases.index(phase) + 1
                if next_phase_index < len(self.sdlc_phases):
                    self.state['current_services'][service] = self.sdlc_phases[next_phase_index]
                else:
                    # Completed all phases
                    if len(phases_passed) == len(self.sdlc_phases):
                        production_ready = True
            else:
                print(f"   ‚ö†Ô∏è  {phase} phase needs work")
                self.state['current_services'][service] = phase
                break
            
            # Check for timeout
            if not self.claude_available:
                print("   ‚è∞ Claude timeout - will retry later")
                break
            
            self.save_state()
            
            # Small delay between phases
            time.sleep(5)
        
        if production_ready:
            print(f"\nüéâ {service} is PRODUCTION READY after {iteration} iterations!")
            self.state['production_ready'].append(service)
            self.state['current_services'].pop(service, None)
            self.save_state()
            
            # Create production ready issue
            self.create_production_ready_issue(service, repo, iteration)
        elif not self.claude_available:
            print(f"\n‚è∏Ô∏è  Pausing {service} due to timeout")
        else:
            print(f"\nüîÑ {service} needs another iteration")
            
            # Schedule next iteration
            if iteration < 10:  # Max 10 iterations
                print(f"   Will start iteration {iteration + 1} after other services")
    
    def update_issue_with_phase_results(self, repo: str, issue_number: int, results: Dict):
        """Update issue with phase execution results"""
        
        comment = f"""## Phase Execution Results

**Phase**: {results['phase']}
**Status**: {'‚úÖ Passed' if results.get('ready_for_next') else '‚ö†Ô∏è Needs Work'}
**Executed**: {results['timestamp']}

### Metrics
"""
        
        for metric, value in results.get('metrics', {}).items():
            comment += f"- **{metric}**: {value}\n"
        
        if results.get('issues'):
            comment += "\n### Issues Found\n"
            for issue in results['issues']:
                comment += f"- {issue}\n"
        
        comment += f"""

### Next Steps
"""
        
        if results.get('ready_for_next'):
            next_phase_index = self.sdlc_phases.index(results['phase']) + 1
            if next_phase_index < len(self.sdlc_phases):
                comment += f"Moving to **{self.sdlc_phases[next_phase_index]}** phase"
            else:
                comment += "All phases complete - checking production readiness"
        else:
            comment += f"Addressing issues in **{results['phase']}** phase before proceeding"
        
        comment += "\n\n---\n*Automated by SDLC Iterator Agent*"
        
        # Post comment
        try:
            comment_file = self.base_dir / "temp_comment.md"
            comment_file.write_text(comment)
            
            cmd = f'gh issue comment {issue_number} --repo stevesurles/{repo} --body-file "{comment_file}"'
            subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            # Close issue if phase passed
            if results.get('ready_for_next'):
                cmd = f'gh issue close {issue_number} --repo stevesurles/{repo}'
                subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            comment_file.unlink(missing_ok=True)
            
        except Exception as e:
            print(f"Error updating issue: {e}")
    
    def create_production_ready_issue(self, service: str, repo: str, iterations: int):
        """Create issue announcing service is production ready"""
        
        title = f"üéâ {service} is PRODUCTION READY!"
        
        body = f"""# Production Ready Certification

## Service: {service}
## Repository: {repo}
## Iterations Required: {iterations}

### ‚úÖ All SDLC Phases Passed

- **Develop**: Code quality verified, linting passed
- **Test**: All tests passing, coverage > 80%
- **Deploy**: Deployment configuration validated
- **Document**: Documentation complete and up-to-date

### Production Readiness Checklist

- [x] Code quality standards met
- [x] Test coverage adequate
- [x] Security review completed
- [x] Performance benchmarks passed
- [x] Deployment automation ready
- [x] Documentation comprehensive
- [x] Rollback plan established

### Next Steps

1. Final manual review
2. Production deployment approval
3. Monitor initial deployment
4. Update production documentation

### Statistics

- Total iterations: {iterations}
- Total phases completed: {iterations * 4}
- Time to production ready: Automated SDLC process

---
*Certified by SDLC Iterator Agent on {datetime.now().isoformat()}*
"""
        
        cmd = f'gh issue create --repo stevesurles/{repo} --title "{title}" --body "{body}" --label "production-ready,milestone"'
        
        try:
            body_file = self.base_dir / "temp_issue.md"
            body_file.write_text(body)
            
            cmd = f'gh issue create --repo stevesurles/{repo} --title "{title}" --body-file "{body_file}" --label "production-ready,milestone"'
            subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            body_file.unlink(missing_ok=True)
            
        except Exception as e:
            print(f"Error creating production ready issue: {e}")
    
    def run_continuous_iteration(self):
        """Run continuous SDLC iteration with retry handling"""
        
        print("\n" + "="*60)
        print("üîÑ SDLC CONTINUOUS ITERATOR")
        print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*60)
        
        services_to_process = [
            ('NiroSubs-V2', 'ns-auth'),
            ('NiroSubs-V2', 'ns-dashboard'),
            ('NiroSubs-V2', 'ns-payments'),
            ('VisualForgeMediaV2', 'vf-audio-service'),
            ('VisualForgeMediaV2', 'vf-video-service'),
        ]
        
        while True:
            try:
                # Check for retries first
                self.check_retries()
                
                # Process services not yet production ready
                for repo, service in services_to_process:
                    if service not in self.state['production_ready']:
                        self.iterate_service_sdlc(service, repo)
                        
                        # Check if we hit a timeout
                        if not self.claude_available:
                            print("\n‚è∞ Claude unavailable - waiting 30 minutes...")
                            time.sleep(1800)  # Wait 30 minutes
                            
                            # Test availability
                            if self.test_claude_availability():
                                self.claude_available = True
                                print("‚úÖ Claude available again!")
                        else:
                            # Small delay between services
                            time.sleep(10)
                
                # Check if all services are production ready
                all_ready = all(
                    service in self.state['production_ready'] 
                    for _, service in services_to_process
                )
                
                if all_ready:
                    print("\nüéä ALL SERVICES ARE PRODUCTION READY!")
                    break
                
                # Wait before next iteration cycle
                print("\nüí§ Waiting 10 minutes before next iteration cycle...")
                time.sleep(600)
                
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è  Stopping iterator...")
                break
            except Exception as e:
                print(f"\n‚ùå Error: {e}")
                print("Retrying in 5 minutes...")
                time.sleep(300)

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='SDLC Iterator Agent')
    parser.add_argument('--continuous', action='store_true', help='Run continuous iteration')
    parser.add_argument('--check-retries', action='store_true', help='Check retry queue')
    parser.add_argument('--reset', action='store_true', help='Reset all state')
    
    args = parser.parse_args()
    
    agent = SDLCIteratorAgent()
    
    if args.reset:
        agent.state = {
            'current_services': {},
            'completed_services': [],
            'production_ready': [],
            'iteration_count': {}
        }
        agent.retry_queue = []
        agent.save_state()
        agent.save_retry_queue()
        print("‚úÖ State reset")
        
    elif args.check_retries:
        print(f"Retry queue: {len(agent.retry_queue)} items")
        for task in agent.retry_queue:
            print(f"  - {task['service']}: {task['phase']} (retry at {task['scheduled_retry']})")
        agent.check_retries()
        
    elif args.continuous:
        agent.run_continuous_iteration()
        
    else:
        print("\nüîÑ SDLC Iterator Agent")
        print("=======================")
        print("1. Start continuous iteration")
        print("2. Check retry queue")
        print("3. Reset state")
        print("4. Exit")
        
        choice = input("\nSelect: ")
        
        if choice == '1':
            agent.run_continuous_iteration()
        elif choice == '2':
            agent.check_retries()
        elif choice == '3':
            agent.state = {
                'current_services': {},
                'completed_services': [],
                'production_ready': [],
                'iteration_count': {}
            }
            agent.retry_queue = []
            agent.save_state()
            agent.save_retry_queue()
            print("‚úÖ State reset")

if __name__ == "__main__":
    main()